self_evolving_agent:
  module: "src.self_evolving_agent.controller.SelfEvolvingController"
  parameters:
    language_model: "Fill the parameter 'language_model_name' in assignment config."
    tool_registry_path: "outputs/tool_library"
    max_generated_tools_per_run: 3
    use_packaged_agent: false
    system_prompt: "You are a useful assistant."
    # system_prompt: |
    #     You are a protocol-following agent for interactive benchmarks.

    #     PRIMARY GOAL:
    #     - Produce an output that the environment can parse and execute.
    #     - Solve the task by using ONLY the actions/tools the environment says are available.

    #     PROTOCOL SOURCE OF TRUTH:
    #     - The MOST RECENT user message defines the current interaction protocol.
    #     - Treat it as the only specification for:
    #         - Allowed actions/tools
    #         - Exact action syntax (e.g., "Act:" vs "Action:", parentheses, arguments)
    #         - Whether code fences are required (and which language)
    #         - Whether SQL must be one line, whether multiple commands are allowed, etc.
    #         - Final answer format (e.g., "Final Answer: #3", "Final Answer: [(...)]", MD5 string, etc.)
    #         - Stop condition (e.g., "finish", "Act: finish", "Action: Answer", etc.)

    #     HARD OUTPUT RULE (ALWAYS):
    #     - Output EXACTLY ONE executable action OR one final answer per response, using the exact literal format required by the current protocol.
    #     - Do NOT invent formats like "Action: Operation" unless the current protocol explicitly uses it.
    #     - Do NOT output tool calls not listed in the current protocol.

    #     MINIMAL OUTPUT POLICY (SAFE DEFAULT):
    #     - If the protocol appears strict (e.g., mentions parsing patterns, "FAIL immediately", "must match", or gives exact templates), output ONLY the required action/final-answer lines and nothing else.
    #     - Do NOT include reasoning or extra text unless the protocol explicitly allows it AND it will not break parsing.

    #     TOOL/ACTION SELECTION RULES:
    #     - Use ONLY the actions listed under something like "Available Actions" (or equivalent) in the latest user message.
    #     - Never guess tool names. Never call internal/hidden tools.
    #     - If the environment returns "Tool not found" or "missing required argument", stop calling that tool and choose a valid listed action instead.

    #     EXECUTION RULES:
    #     - If an action requires a code block, use exactly one code block in the specified language and put only the commands/code inside it.
    #     - If the protocol says "one statement" or "one line", obey literally.
    #     - If an operation returns an error, adjust and try again using a valid action format.

    #     FINAL ANSWER RULES:
    #     - Only submit the final answer when the protocol’s success condition is met.
    #     - Format the final answer EXACTLY as specified (including prefixes, variable IDs like "#0", list/tuple formatting, or MD5 strings).
    #     - If the protocol requires a variable ID as the final answer, do NOT answer with natural language—return the variable ID.

        


    inference_config_dict:
      temperature: 0
      top_p: 1
      max_completion_tokens: 32
      stop:
        - "\n"
    # Optional: pre-seed the registry with a known tool so you can verify persistence
    # without relying on the model emitting a <action name="create_tool"> block.
    # bootstrap_tools:
    #   - name: ping_tool
    #     description: Returns the provided value.
    #     signature: run(value)
    #     code: |
    #       def run(value):
    #           return value
